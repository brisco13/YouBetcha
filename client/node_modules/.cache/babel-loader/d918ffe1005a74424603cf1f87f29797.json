{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { useRef } from \"react\";\nimport { equal } from \"@wry/equality\";\nimport { mergeDeepArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nexport function useFragment_experimental(options) {\n  var cache = useApolloClient().cache;\n\n  var fragment = options.fragment,\n      fragmentName = options.fragmentName,\n      from = options.from,\n      _a = options.optimistic,\n      optimistic = _a === void 0 ? true : _a,\n      rest = __rest(options, [\"fragment\", \"fragmentName\", \"from\", \"optimistic\"]);\n\n  var diffOptions = __assign(__assign({}, rest), {\n    id: typeof from === \"string\" ? from : cache.identify(from),\n    query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n    optimistic: optimistic\n  });\n\n  var resultRef = useRef();\n  var latestDiff = cache.diff(diffOptions);\n  return useSyncExternalStore(function (forceUpdate) {\n    var immediate = true;\n    return cache.watch(__assign(__assign({}, diffOptions), {\n      immediate: immediate,\n      callback: function (diff) {\n        if (!immediate && !equal(diff, latestDiff)) {\n          resultRef.current = diffToResult(latestDiff = diff);\n          forceUpdate();\n        }\n\n        immediate = false;\n      }\n    }));\n  }, function () {\n    var latestDiffToResult = diffToResult(latestDiff);\n    return resultRef.current && equal(resultRef.current.data, latestDiffToResult.data) ? resultRef.current : resultRef.current = latestDiffToResult;\n  });\n}\n\nfunction diffToResult(diff) {\n  var result = {\n    data: diff.result,\n    complete: !!diff.complete\n  };\n\n  if (diff.missing) {\n    result.missing = mergeDeepArray(diff.missing.map(function (error) {\n      return error.missing;\n    }));\n  }\n\n  return result;\n}","map":{"version":3,"mappings":";AAAA,SAASA,MAAT,QAAuB,OAAvB;AACA,SAASC,KAAT,QAAsB,eAAtB;AAEA,SAASC,cAAT,QAA+B,0BAA/B;AAQA,SAASC,eAAT,QAAgC,sBAAhC;AACA,SAASC,oBAAT,QAAqC,2BAArC;AAsCA,OAAM,SAAUC,wBAAV,CACJC,OADI,EACqC;EAEjC,SAAK,GAAKH,eAAe,GAAEI,KAA3B;;EAGN,YAAQ,GAKND,OAAO,SALT;EAAA,IACAE,YAAY,GAIVF,OAAO,aALT;EAAA,IAEAG,IAAI,GAGFH,OAAO,KALT;EAAA,IAGAI,KAEEJ,OAAO,WALT;EAAA,IAGAK,UAAU,mBAAG,IAAH,GAAOD,EAHjB;EAAA,IAIGE,IAAI,UACLN,OADK,EALH,kDAKG,CAJP;;EAOF,IAAMO,WAAW,yBACZD,IADY,GACR;IACPE,EAAE,EAAE,OAAOL,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkCF,KAAK,CAACQ,QAAN,CAAeN,IAAf,CAD/B;IAEPO,KAAK,EAAET,KAAK,CAAC,gBAAD,CAAL,CAAwBU,QAAxB,EAAkCT,YAAlC,CAFA;IAGPG,UAAU;EAHH,CADQ,CAAjB;;EAOA,IAAMO,SAAS,GAAGlB,MAAM,EAAxB;EACA,IAAImB,UAAU,GAAGZ,KAAK,CAACa,IAAN,CAAkBP,WAAlB,CAAjB;EAEA,OAAOT,oBAAoB,CACzB,uBAAW;IACT,IAAIiB,SAAS,GAAG,IAAhB;IACA,OAAOd,KAAK,CAACe,KAAN,CAAWC,sBACbV,WADa,GACF;MACdQ,SAAS,WADK;MAEdG,QAAQ,YAACJ,IAAD,EAAK;QACX,IAAI,CAACC,SAAD,IAAc,CAACpB,KAAK,CAACmB,IAAD,EAAOD,UAAP,CAAxB,EAA4C;UAC1CD,SAAS,CAACO,OAAV,GAAoBC,YAAY,CAACP,UAAU,GAAGC,IAAd,CAAhC;UACAO,WAAW;QACZ;;QACDN,SAAS,GAAG,KAAZ;MACD;IARa,CADE,CAAX,CAAP;EAWD,CAdwB,EAgBzB;IACE,IAAMO,kBAAkB,GAAGF,YAAY,CAACP,UAAD,CAAvC;IACA,OAAOD,SAAS,CAACO,OAAV,IACLxB,KAAK,CAACiB,SAAS,CAACO,OAAV,CAAkBI,IAAnB,EAAyBD,kBAAkB,CAACC,IAA5C,CADA,GAEHX,SAAS,CAACO,OAFP,GAGFP,SAAS,CAACO,OAAV,GAAoBG,kBAHzB;EAID,CAtBwB,CAA3B;AAwBD;;AAED,SAASF,YAAT,CACEN,IADF,EAC+B;EAE7B,IAAMU,MAAM,GAA6B;IACvCD,IAAI,EAAET,IAAI,CAACU,MAD4B;IAEvCC,QAAQ,EAAE,CAAC,CAACX,IAAI,CAACW;EAFsB,CAAzC;;EAKA,IAAIX,IAAI,CAACY,OAAT,EAAkB;IAChBF,MAAM,CAACE,OAAP,GAAiB9B,cAAc,CAC7BkB,IAAI,CAACY,OAAL,CAAaC,GAAb,CAAiB,iBAAK;MAAI,YAAK,CAACD,OAAN;IAAa,CAAvC,CAD6B,CAA/B;EAGD;;EAED,OAAOF,MAAP;AACD","names":["useRef","equal","mergeDeepArray","useApolloClient","useSyncExternalStore","useFragment_experimental","options","cache","fragmentName","from","_a","optimistic","rest","diffOptions","id","identify","query","fragment","resultRef","latestDiff","diff","immediate","watch","__assign","callback","current","diffToResult","forceUpdate","latestDiffToResult","data","result","complete","missing","map"],"sources":["/Users/amccorkl/Computer/Project3/YouBetcha/client/node_modules/@apollo/src/react/hooks/useFragment.ts"],"sourcesContent":["import { useRef } from \"react\";\nimport { equal } from \"@wry/equality\";\n\nimport { mergeDeepArray } from \"../../utilities\";\nimport {\n  Cache,\n  Reference,\n  StoreObject,\n  MissingTree,\n} from \"../../cache\";\n\nimport { useApolloClient } from \"./useApolloClient\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore\";\n\nexport interface UseFragmentOptions<TData, TVars>\nextends Omit<\n  Cache.DiffOptions<TData, TVars>,\n  | \"id\"\n  | \"query\"\n  | \"optimistic\"\n  | \"previousResult\"\n>, Omit<\n  Cache.ReadFragmentOptions<TData, TVars>,\n  | \"id\"\n> {\n  from: StoreObject | Reference | string;\n  // Override this field to make it optional (default: true).\n  optimistic?: boolean;\n}\n\n// Since the above definition of UseFragmentOptions can be hard to parse without\n// help from TypeScript/VSCode, here are the intended fields and their types.\n// Uncomment this code to check that it's consistent with the definition above.\n//\n// export interface UseFragmentOptions<TData, TVars> {\n//   from: string | StoreObject | Reference;\n//   fragment: DocumentNode | TypedDocumentNode<TData, TVars>;\n//   fragmentName?: string;\n//   optimistic?: boolean;\n//   variables?: TVars;\n//   returnPartialData?: boolean;\n//   canonizeResults?: boolean;\n// }\n\nexport interface UseFragmentResult<TData> {\n  data: TData | undefined;\n  complete: boolean;\n  missing?: MissingTree;\n}\n\nexport function useFragment_experimental<TData, TVars>(\n  options: UseFragmentOptions<TData, TVars>,\n): UseFragmentResult<TData> {\n  const { cache } = useApolloClient();\n\n  const {\n    fragment,\n    fragmentName,\n    from,\n    optimistic = true,\n    ...rest\n  } = options;\n\n  const diffOptions: Cache.DiffOptions<TData, TVars> = {\n    ...rest,\n    id: typeof from === \"string\" ? from : cache.identify(from),\n    query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n    optimistic,\n  };\n\n  const resultRef = useRef<UseFragmentResult<TData>>();\n  let latestDiff = cache.diff<TData>(diffOptions);\n\n  return useSyncExternalStore(\n    forceUpdate => {\n      let immediate = true;\n      return cache.watch({\n        ...diffOptions,\n        immediate,\n        callback(diff) {\n          if (!immediate && !equal(diff, latestDiff)) {\n            resultRef.current = diffToResult(latestDiff = diff);\n            forceUpdate();\n          }\n          immediate = false;\n        },\n      });\n    },\n\n    () => {\n      const latestDiffToResult = diffToResult(latestDiff);\n      return resultRef.current &&\n        equal(resultRef.current.data, latestDiffToResult.data)\n        ? resultRef.current\n        : (resultRef.current = latestDiffToResult);\n    },\n  );\n}\n\nfunction diffToResult<TData>(\n  diff: Cache.DiffResult<TData>,\n): UseFragmentResult<TData> {\n  const result: UseFragmentResult<TData> = {\n    data: diff.result,\n    complete: !!diff.complete,\n  };\n\n  if (diff.missing) {\n    result.missing = mergeDeepArray(\n      diff.missing.map(error => error.missing),\n    );\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}