{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { Kind } from 'graphql';\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n;\n\nfunction getContextFlavor(context, clientOnly, deferred) {\n  var key = \"\".concat(clientOnly).concat(deferred);\n  var flavored = context.flavors.get(key);\n\n  if (!flavored) {\n    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), {\n      clientOnly: clientOnly,\n      deferred: deferred\n    }));\n  }\n\n  return flavored;\n}\n\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader, fragments) {\n    this.cache = cache;\n    this.reader = reader;\n    this.fragments = fragments;\n  }\n\n  StoreWriter.prototype.writeToStore = function (store, _a) {\n    var _this = this;\n\n    var query = _a.query,\n        result = _a.result,\n        dataId = _a.dataId,\n        variables = _a.variables,\n        overwrite = _a.overwrite;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n\n    var context = __assign(__assign({\n      store: store,\n      written: Object.create(null),\n      merge: function (existing, incoming) {\n        return merger.merge(existing, incoming);\n      },\n      variables: variables,\n      varString: canonicalStringify(variables)\n    }, extractFragmentContext(query, this.fragments)), {\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map()\n    });\n\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: {\n        map: new Map()\n      },\n      context: context\n    });\n\n    if (!isReference(ref)) {\n      throw __DEV__ ? new InvariantError(\"Could not identify object \".concat(JSON.stringify(result))) : new InvariantError(7);\n    }\n\n    context.incomingById.forEach(function (_a, dataId) {\n      var storeObject = _a.storeObject,\n          mergeTree = _a.mergeTree,\n          fieldNodeSet = _a.fieldNodeSet;\n      var entityRef = makeReference(dataId);\n\n      if (mergeTree && mergeTree.map.size) {\n        var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n\n        if (isReference(applied)) {\n          return;\n        }\n\n        storeObject = applied;\n      }\n\n      if (__DEV__ && !context.overwrite) {\n        var fieldsWithSelectionSets_1 = Object.create(null);\n        fieldNodeSet.forEach(function (field) {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets_1[field.name.value] = true;\n          }\n        });\n\n        var hasSelectionSet_1 = function (storeFieldName) {\n          return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n        };\n\n        var hasMergeFunction_1 = function (storeFieldName) {\n          var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n\n        Object.keys(storeObject).forEach(function (storeFieldName) {\n          if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n          }\n        });\n      }\n\n      store.merge(dataId, storeObject);\n    });\n    store.retain(ref.__ref);\n    return ref;\n  };\n\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n\n    var dataId = _a.dataId,\n        result = _a.result,\n        selectionSet = _a.selectionSet,\n        context = _a.context,\n        mergeTree = _a.mergeTree;\n    var policies = this.cache.policies;\n    var incoming = Object.create(null);\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    var readField = function () {\n      var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n\n      if (isReference(options.from)) {\n        var info = context.incomingById.get(options.from.__ref);\n\n        if (info) {\n          var result_1 = policies.readField(__assign(__assign({}, options), {\n            from: info.storeObject\n          }), context);\n\n          if (result_1 !== void 0) {\n            return result_1;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    var fieldNodeSet = new Set();\n    this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n      var _a;\n\n      var resultFieldKey = resultKeyNameFromField(field);\n      var value = result[resultFieldKey];\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        var storeFieldName = policies.getStoreFieldName({\n          typename: typename,\n          fieldName: field.name.value,\n          field: field,\n          variables: context.variables\n        });\n        var childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);\n\n        var childTypename = void 0;\n\n        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField(\"__typename\", incomingValue);\n        }\n\n        var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n\n        if (merge) {\n          childTree.info = {\n            field: field,\n            typename: typename,\n            merge: merge\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n      } else if (__DEV__ && !context.clientOnly && !context.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {\n        __DEV__ && invariant.error(\"Missing field '\".concat(resultKeyNameFromField(field), \"' while writing result \").concat(JSON.stringify(result, null, 2)).substring(0, 1000));\n      }\n    });\n\n    try {\n      var _b = policies.identify(result, {\n        typename: typename,\n        selectionSet: selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField: readField\n      }),\n          id = _b[0],\n          keyObject = _b[1];\n\n      dataId = dataId || id;\n\n      if (keyObject) {\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      var dataRef = makeReference(dataId);\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n        return dataRef;\n      }\n\n      var previous_1 = context.incomingById.get(dataId);\n\n      if (previous_1) {\n        previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n        previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n        fieldNodeSet.forEach(function (field) {\n          return previous_1.fieldNodeSet.add(field);\n        });\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet: fieldNodeSet\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  };\n\n  StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n    var _this = this;\n\n    if (!field.selectionSet || value === null) {\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map(function (item, i) {\n        var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      mergeTree: mergeTree\n    });\n  };\n\n  StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n    if (typename === void 0) {\n      typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);\n    }\n\n    var fieldMap = new Map();\n    var policies = this.cache.policies;\n    var limitingTrie = new Trie(false);\n\n    (function flatten(selectionSet, inheritedContext) {\n      var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n      selectionSet.selections.forEach(function (selection) {\n        if (!shouldInclude(selection, context.variables)) return;\n        var clientOnly = inheritedContext.clientOnly,\n            deferred = inheritedContext.deferred;\n\n        if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {\n          selection.directives.forEach(function (dir) {\n            var name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n\n            if (name === \"defer\") {\n              var args = argumentsObjectFromField(dir, context.variables);\n\n              if (!args || args.if !== false) {\n                deferred = true;\n              }\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          var existing = fieldMap.get(selection);\n\n          if (existing) {\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n        } else {\n          var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw __DEV__ ? new InvariantError(\"No fragment named \".concat(selection.name.value)) : new InvariantError(8);\n          }\n\n          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  };\n\n  StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n    var _a;\n\n    var _this = this;\n\n    if (mergeTree.map.size && !isReference(incoming)) {\n      var e_1 = !isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;\n      var i_1 = incoming;\n\n      if (e_1 && !getStorageArgs) {\n        getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n      }\n\n      var changedFields_1;\n\n      var getValue_1 = function (from, name) {\n        return isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n      };\n\n      mergeTree.map.forEach(function (childTree, storeFieldName) {\n        var eVal = getValue_1(e_1, storeFieldName);\n        var iVal = getValue_1(i_1, storeFieldName);\n        if (void 0 === iVal) return;\n\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n\n        var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n\n        if (aVal !== iVal) {\n          changedFields_1 = changedFields_1 || new Map();\n          changedFields_1.set(storeFieldName, aVal);\n        }\n\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields_1) {\n        incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n        changedFields_1.forEach(function (value, name) {\n          incoming[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n    }\n\n    return incoming;\n  };\n\n  return StoreWriter;\n}();\n\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\n\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || {\n      map: new Map()\n    });\n  }\n\n  return map.get(name);\n}\n\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;\n  var merged = {\n    info: info,\n    map: map\n  };\n\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function (leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function (key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nvar warnings = new Set();\n\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  __DEV__ && invariant.warn(\"Cache data may be lost when replacing the \".concat(fieldName, \" field of a \").concat(parentType, \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \").concat(childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", \"define a custom merge function for the \").concat(typeDotName, \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \").concat(JSON.stringify(existing).slice(0, 1000), \"\\n  incoming: \").concat(JSON.stringify(incoming).slice(0, 1000), \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\"));\n}","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","equal","Trie","Kind","getFragmentFromSelection","getDefaultValues","getOperationDefinition","getTypenameFromResult","makeReference","isField","resultKeyNameFromField","isReference","shouldInclude","cloneDeep","addTypenameToDocument","isNonEmptyArray","argumentsObjectFromField","isArray","makeProcessedFieldsMerger","fieldNameFromStoreName","storeValueIsStoreObject","extractFragmentContext","canonicalStringify","normalizeReadFieldOptions","getContextFlavor","context","clientOnly","deferred","key","concat","flavored","flavors","get","set","__assign","cache","reader","fragments","StoreWriter","store","_a","query","result","dataId","variables","overwrite","operationDefinition","merger","written","Object","create","merge","existing","incoming","varString","incomingById","Map","ref","processSelectionSet","selectionSet","mergeTree","map","__DEV__","JSON","stringify","forEach","storeObject","fieldNodeSet","entityRef","size","applied","_this","applyMerges","fieldsWithSelectionSets_1","field","name","value","hasSelectionSet_1","storeFieldName","hasMergeFunction_1","childTree","Boolean","info","keys","warnAboutDataLoss","retain","__ref","policies","typename","rootTypenamesById","fragmentMap","__typename","readField","options","arguments","from","result_1","Set","flattenFields","resultFieldKey","add","getStoreFieldName","fieldName","getChildMergeTree","incomingValue","processFieldValue","childTypename","getMergeFunction","maybeRecycleChildMergeTree","added","getReadFunction","substring","identify","id","keyObject","e","dataRef","sets","indexOf","push","isFresh","previous_1","mergeMergeTrees","mergeTreeIsEmpty","item","i","fieldMap","limitingTrie","flatten","inheritedContext","visitedNode","lookup","visited","selections","selection","directives","dir","args","if","fragment","lookupFragment","kind","FRAGMENT_SPREAD","fragmentMatches","getStorageArgs","e_1","i_1","changedFields_1","getValue_1","getFieldValue","String","eVal","iVal","aVal","pop","slice","runMergeFunction","getStorage","apply","emptyMergeTreePool","has","left","right","needToMergeMaps","merged","remainingRightKeys_1","leftTree","delete","tree","warnings","existingRef","incomingObj","getChild","objOrRef","child","every","parentType","typeDotName","childTypenames","includes","join"],"sources":["/Users/amccorkl/Computer/Project3/YouBetcha/client/node_modules/@apollo/src/cache/inmemory/writeToStore.ts"],"sourcesContent":["import { invariant, InvariantError } from '../../utilities/globals';\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport {\n  SelectionSetNode,\n  FieldNode,\n  Kind,\n} from 'graphql';\n\nimport {\n  FragmentMap,\n  FragmentMapFunction,\n  getFragmentFromSelection,\n  getDefaultValues,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  Reference,\n  isReference,\n  shouldInclude,\n  cloneDeep,\n  addTypenameToDocument,\n  isNonEmptyArray,\n  argumentsObjectFromField,\n} from '../../utilities';\n\nimport { NormalizedCache, ReadMergeModifyContext, MergeTree, InMemoryCacheConfig } from './types';\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from './helpers';\nimport { StoreReader } from './readFromStore';\nimport { InMemoryCache } from './inMemoryCache';\nimport { EntityStore } from './entityStore';\nimport { Cache } from '../../core';\nimport { canonicalStringify } from './object-canon';\nimport { normalizeReadFieldOptions } from './policies';\nimport { ReadFieldFunction } from '../core/types/common';\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<string, {\n    storeObject: StoreObject;\n    mergeTree?: MergeTree;\n    fieldNodeSet: Set<FieldNode>;\n  }>;\n  // Directive metadata for @client and @defer. We could use a bitfield for this\n  // information to save some space, and use that bitfield number as the keys in\n  // the context.flavors Map.\n  clientOnly: boolean;\n  deferred: boolean;\n  flavors: Map<string, FlavorableWriteContext>;\n};\n\ntype FlavorableWriteContext = Pick<\n  WriteContext,\n  | \"clientOnly\"\n  | \"deferred\"\n  | \"flavors\"\n>;\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor<TContext extends FlavorableWriteContext>(\n  context: TContext,\n  clientOnly: TContext[\"clientOnly\"],\n  deferred: TContext[\"deferred\"],\n): TContext {\n  const key = `${clientOnly}${deferred}`;\n  let flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(key, flavored = (\n      context.clientOnly === clientOnly &&\n      context.deferred === deferred\n    ) ? context : {\n      ...context,\n      clientOnly,\n      deferred,\n    });\n  }\n  return flavored as TContext;\n}\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string,\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n    private fragments?: InMemoryCacheConfig[\"fragments\"],\n  ) {}\n\n  public writeToStore(store: NormalizedCache, {\n    query,\n    result,\n    dataId,\n    variables,\n    overwrite,\n  }: Cache.WriteOptions): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: Object.create(null),\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables,\n      varString: canonicalStringify(variables),\n      ...extractFragmentContext(query, this.fragments),\n      overwrite: !!overwrite,\n      incomingById: new Map,\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map,\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw new InvariantError(`Could not identify object ${JSON.stringify(result)}`);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n      const entityRef = makeReference(dataId);\n\n      if (mergeTree && mergeTree.map.size) {\n        const applied = this.applyMerges(mergeTree, entityRef, storeObject, context);\n        if (isReference(applied)) {\n          // Assume References returned by applyMerges have already been merged\n          // into the store. See makeMergeObjectsFunction in policies.ts for an\n          // example of how this can happen.\n          return;\n        }\n        // Otherwise, applyMerges returned a StoreObject, whose fields we should\n        // merge into the store (see store.merge statement below).\n        storeObject = applied;\n      }\n\n      if (__DEV__ && !context.overwrite) {\n        const fieldsWithSelectionSets: Record<string, true> = Object.create(null);\n        fieldNodeSet.forEach(field => {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets[field.name.value] = true;\n          }\n        });\n\n        const hasSelectionSet = (storeFieldName: string) =>\n          fieldsWithSelectionSets[\n            fieldNameFromStoreName(storeFieldName)\n          ] === true;\n\n        const hasMergeFunction = (storeFieldName: string) => {\n          const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n\n        Object.keys(storeObject).forEach(storeFieldName => {\n          // If a merge function was defined for this field, trust that it\n          // did the right thing about (not) clobbering data. If the field\n          // has no selection set, it's a scalar field, so it doesn't need\n          // a merge function (even if it's an object, like JSON data).\n          if (hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)) {\n            warnAboutDataLoss(\n              entityRef,\n              storeObject,\n              storeFieldName,\n              context.store,\n            );\n          }\n        });\n      }\n\n      store.merge(dataId, storeObject);\n    });\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incoming: StoreObject = Object.create(null);\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && context.store.get(dataId, \"__typename\") as string);\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    const readField: ReadFieldFunction = function (this: void) {\n      const options = normalizeReadFieldOptions(\n        arguments,\n        incoming,\n        context.variables,\n      );\n\n      if (isReference(options.from)) {\n        const info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          const result = policies.readField({\n            ...options,\n            from: info.storeObject\n          }, context);\n\n          if (result !== void 0) {\n            return result;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    const fieldNodeSet = new Set<FieldNode>();\n\n    this.flattenFields(\n      selectionSet,\n      result,\n      // This WriteContext will be the default context value for fields returned\n      // by the flattenFields method, but some fields may be assigned a modified\n      // context, depending on the presence of @client and other directives.\n      context,\n      typename,\n    ).forEach((context, field) => {\n      const resultFieldKey = resultKeyNameFromField(field);\n      const value = result[resultFieldKey];\n\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        const storeFieldName = policies.getStoreFieldName({\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        });\n\n        const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        let incomingValue = this.processFieldValue(\n          value,\n          field,\n          // Reset context.clientOnly and context.deferred to their default\n          // values before processing nested selection sets.\n          field.selectionSet\n            ? getContextFlavor(context, false, false)\n            : context,\n          childTree,\n        );\n\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        let childTypename: string | undefined;\n\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (field.selectionSet &&\n            (isReference(incomingValue) ||\n             storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField<string>(\"__typename\", incomingValue);\n        }\n\n        const merge = policies.getMergeFunction(\n          typename,\n          field.name.value,\n          childTypename,\n        );\n\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field,\n            typename,\n            merge,\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, {\n          [storeFieldName]: incomingValue,\n        });\n\n      } else if (\n        __DEV__ &&\n        !context.clientOnly &&\n        !context.deferred &&\n        !addTypenameToDocument.added(field) &&\n        // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)\n      ) {\n        invariant.error(`Missing field '${\n          resultKeyNameFromField(field)\n        }' while writing result ${\n          JSON.stringify(result, null, 2)\n        }`.substring(0, 1000));\n      }\n    });\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      const [id, keyObject] = policies.identify(result, {\n        typename,\n        selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField,\n      });\n\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      const dataRef = makeReference(dataId);\n\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (this.reader && this.reader.isFresh(\n        result,\n        dataRef,\n        selectionSet,\n        context,\n      )) {\n        return dataRef;\n      }\n\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.storeObject = context.merge(previous.storeObject, incoming);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        fieldNodeSet.forEach(field => previous.fieldNodeSet.add(field));\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet,\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree,\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  private flattenFields<TContext extends Pick<\n    WriteContext,\n    | \"clientOnly\"\n    | \"deferred\"\n    | \"flavors\"\n    | \"fragmentMap\"\n    | \"lookupFragment\"\n    | \"variables\"\n  >>(\n    selectionSet: SelectionSetNode,\n    result: Record<string, any>,\n    context: TContext,\n    typename = getTypenameFromResult(result, selectionSet, context.fragmentMap),\n  ): Map<FieldNode, TContext> {\n    const fieldMap = new Map<FieldNode, TContext>();\n    const { policies } = this.cache;\n\n    const limitingTrie = new Trie<{\n      // Tracks whether (selectionSet, clientOnly, deferred) has been flattened\n      // before. The GraphQL specification only uses the fragment name for\n      // skipping previously visited fragments, but the top-level fragment\n      // selection set corresponds 1:1 with the fagment name (and is slightly\n      // easier too work with), and we need to consider clientOnly and deferred\n      // values as well, potentially revisiting selection sets that were\n      // previously visited with different inherited configurations of those\n      // directives.\n      visited?: boolean;\n    }>(false); // No need for WeakMap, since limitingTrie does not escape.\n\n    (function flatten(\n      this: void,\n      selectionSet: SelectionSetNode,\n      inheritedContext: TContext,\n    ) {\n      const visitedNode = limitingTrie.lookup(\n        selectionSet,\n        // Because we take inheritedClientOnly and inheritedDeferred into\n        // consideration here (in addition to selectionSet), it's possible for\n        // the same selection set to be flattened more than once, if it appears\n        // in the query with different @client and/or @directive configurations.\n        inheritedContext.clientOnly,\n        inheritedContext.deferred,\n      );\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n\n      selectionSet.selections.forEach(selection => {\n        if (!shouldInclude(selection, context.variables)) return;\n\n        let { clientOnly, deferred } = inheritedContext;\n        if (\n          // Since the presence of @client or @defer on this field can only\n          // cause clientOnly or deferred to become true, we can skip the\n          // forEach loop if both clientOnly and deferred are already true.\n          !(clientOnly && deferred) &&\n          isNonEmptyArray(selection.directives)\n        ) {\n          selection.directives.forEach(dir => {\n            const name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              const args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || (args as { if?: boolean }).if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          const existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(\n            selection,\n            getContextFlavor(context, clientOnly, deferred),\n          );\n\n        } else {\n          const fragment = getFragmentFromSelection(\n            selection,\n            context.lookupFragment,\n          );\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n\n          if (fragment &&\n              policies.fragmentMatches(\n                fragment, typename, result, context.variables)) {\n\n            flatten(\n              fragment.selectionSet,\n              getContextFlavor(context, clientOnly, deferred),\n            );\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>,\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined = (\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        !isArray(incoming) &&\n        // Likewise, existing must be either a Reference or a StoreObject\n        // in order for its fields to be safe to merge with the fields of\n        // the incoming object.\n        (isReference(existing) || storeValueIsStoreObject(existing))\n      ) ? existing : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number,\n      ): StoreValue => {\n        return isArray(from)\n          ? (typeof name === \"number\" ? from[name] : void 0)\n          : context.store.getFieldValue(from, String(name))\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs,\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map;\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs),\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined,\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info = left.info && right.info ? {\n    ...left.info,\n    ...right.info,\n  } : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map = needToMergeMaps ? new Map :\n    left.map.size ? left.map : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(leftTree, right.map.get(key)),\n      );\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach(key => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(\n          right.map.get(key),\n          left.map.get(key),\n        ),\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache,\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (Object.keys(existing).every(\n    key => store.getFieldValue(incoming, key) !== void 0)) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) &&\n      !isArray(incoming)) {\n    [existing, incoming].forEach(child => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" &&\n          !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n`Cache data may be lost when replacing the ${fieldName} field of a ${parentType} object.\n\nTo address this problem (which is not a bug in Apollo Client), ${\n  childTypenames.length\n    ? \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n    : \"\"\n}define a custom merge function for the ${\n  typeDotName\n} field, so InMemoryCache can safely merge these objects:\n\n  existing: ${JSON.stringify(existing).slice(0, 1000)}\n  incoming: ${JSON.stringify(incoming).slice(0, 1000)}\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`);\n}\n"]},"metadata":{},"sourceType":"module"}